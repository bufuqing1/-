<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8" />
		<title></title>
	</head>
	<body>
		<script>
		// 步骤一、
			// let a1 = [1, 2, 3];
			// let [b1, c1] = a1;
			// console.log(a1, b1, c1);
			// 这里使用了解构赋值，a1 数组被解构为 b1 和 c1。b1 将会是 1，c1 将会是 2（数组的第三个元素 3 没有对应的变量接收，所以被忽略）。
			// 预期输出：[1, 2, 3] 1 2
			
			// let [a2, b2, c2] = [1, 2, 3];
			// console.log(a2, b2, c2);
			// 同样使用解构赋值，数组 [1, 2, 3] 被完全解构到 a2、b2 和 c2。
			// 预期输出：1 2 3
			
			// let [a3, b3, c3] = [1, 3];
			// console.log(a3, b3, c3);
			// 这里数组 [1, 3] 被解构到 a3 和 b3，c3 没有被赋值，所以 c3 将会是 undefined。
			// 预期输出：1 3 undefined
			
			// let [a4, b4] = [1];
			// console.log(a4, b4);
			// 数组 [1] 只有一个元素，解构赋值给 a4，b4 没有被赋值，所以 b4 将会是 undefined。
			// 预期输出：1 undefined
			
			
			// let {x: a5, y: b5} = {x: 1, y: 2};
			// console.log(a5, b5);
			// 这是一个对象解构赋值的例子，{x: a5, y: b5} 表示从对象中提取 x 和 y 属性，并分别赋值给 a5 和 b5。
			// 预期输出：1 2
			
			
			// let [a6, b6] = [1, 2, 3];
			// console.log(a6, b6);
			// 这段代码与第二个代码段相同，将会输出数组 [1, 2, 3] 解构后的 a6、b6。
			// 预期输出：1 2 
			
			
		// 步骤二、
		// let set = new Set();
		// set.add(1);
		// set.add(2);
		// set.add(3);
		// set.delete(2);
		// let i = set.values();
		// console.log(i.next());
		// console.log(i.next());
		// console.log(i.next());
		// 预期输出：1  3 
		
		
		//  // 步骤三
		// let map = new Map();
		// map.set(1, "a");
		// map.set(2, "b");
		// map.set(3, "c");
		// map.set(4, "d");
		// for (let i = 1; i <= map.size; i++) {
		//     console.log(map.get(i));
		// }
		// map.forEach(function(value, key) {
		//     console.log(value);
		// });
		// for (let v of map.values()) {
		//     console.log(v);
		// }
		// for (var prop in map) {
		//     console.log(prop);
		// }
		// // 最后一段代码没有输出任何结果，因为 for...in 循环不能用于遍历 Map 对象的键。正确的遍历方式是使用 Map 的迭代器方法（如 keys()、values() 和 entries()），或者使用 forEach 方法。
		
		
		// // 步骤四
		// let arr1 = [1, 2, 3];
		// let arr2 = arr1;
		// console.log(arr1 == arr2);
		
		// let arr3 = [...arr1];
		// console.log(arr1 == arr3);
		// // 预期输出是 true 和 false
		// // 这两个结果表明，当使用赋值操作符（=）时，我们得到的是原始数组的引用；而当使用扩展运算符时，我们得到的是原始数组的一个浅拷贝，它们是两个独立的对象
		
		
		// // 步骤五
		// // let arr4 = [1, 2, 3];
		// // arr4.forEach(function(v,k) {
		// //     console.log(v);
		// // });
		// //用箭头函数改写
		// let arr4 = [1, 2, 3];
		// arr4.forEach(v => console.log(v));
		
		
		// // 步骤六
		// Array.of(1, 2, 3).filter(i => i >= 1).forEach(i => console.log(i));
		// // Array.of(1, 2, 3): 这是 Array.of 方法的调用，它是ES6中引入的一个静态方法，用于创建一个包含给定参数的新数组。在这个例子中，它创建了一个包含三个元素 1、2 和 3 的数组
		// // filter(i => i >= 1): 这是 filter 方法的调用，它创建一个新数组，包含通过所提供函数实现的测试的所有元素
		// let fib = n => n > 1 ? fib(n - 1) + fib(n - 2) : n;
		// // 这是一个使用箭头函数定义的斐波那契数列函数。斐波那契数列是一个序列，其中每个数字是前两个数字的和，
		// // 通常从 0 和 1 开始。
		
		
		
		
		//步骤七
		// 定义基类 Animal
		class Animal {
		  constructor(name) {
		    this.name = name;
		  }
		
		  shout() {
		    console.log(`My name is ${this.name} and I can shout!`);
		  }
		}
		
		// 定义子类 Dog，继承自 Animal
		class Dog extends Animal {
		  constructor(name, age) {
		    super(name); // 调用父类的构造函数
		    this.age = age;
		  }
		
		  eat() {
		    console.log(`${this.name} is eating.`);
		  }
		}
		
		// 测试代码
		const dog = new Dog("Buddy", 3);
		dog.shout(); // 调用继承自 Animal 的 shout() 方法
		dog.eat();   // 调用 Dog 类的 eat() 方法
		</script>
	</body>
</html>
